Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> header SEMICOLON global_part block DOT
Rule 2     header -> PROGRAM identifier
Rule 3     global_part -> sub_declaration_list
Rule 4     global_part -> empty
Rule 5     empty -> <empty>
Rule 6     sub_declaration_list -> sub_declaration SEMICOLON sub_declaration_list
Rule 7     sub_declaration_list -> sub_declaration SEMICOLON
Rule 8     variable_declaration_part -> VAR variable_declaration_list
Rule 9     variable_declaration_list -> variable_declaration variable_declaration_list
Rule 10    variable_declaration_list -> variable_declaration
Rule 11    variable_declaration -> identifier_list COLON type SEMICOLON
Rule 12    identifier_list -> identifier COMMA identifier_list
Rule 13    identifier_list -> identifier
Rule 14    identifier -> IDENTIFIER
Rule 15    sub_declaration -> procedure_declaration
Rule 16    sub_declaration -> function_declaration
Rule 17    procedure_declaration -> procedure_heading SEMICOLON block
Rule 18    procedure_heading -> PROCEDURE identifier
Rule 19    procedure_heading -> PROCEDURE identifier LPAREN RPAREN
Rule 20    procedure_heading -> PROCEDURE identifier LPAREN parameter_list RPAREN
Rule 21    function_declaration -> function_heading SEMICOLON block
Rule 22    function_heading -> FUNCTION type
Rule 23    function_heading -> FUNCTION identifier LPAREN RPAREN COLON type
Rule 24    function_heading -> FUNCTION identifier COLON type
Rule 25    function_heading -> FUNCTION identifier LPAREN parameter_list RPAREN COLON type
Rule 26    block -> optional_vardec statement_part
Rule 27    optional_vardec -> variable_declaration_part
Rule 28    optional_vardec -> empty
Rule 29    parameter_list -> parameter COMMA parameter_list
Rule 30    parameter_list -> parameter
Rule 31    parameter -> identifier COLON type
Rule 32    type -> TREAL
Rule 33    type -> TINTEGER
Rule 34    type -> TCHAR
Rule 35    type -> TSTRING
Rule 36    type -> TBOOLEAN
Rule 37    type -> TSTRING LBRACKET integer RBRACKET
Rule 38    type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type
Rule 39    statement_part -> BEGIN statement_sequence END
Rule 40    statement_sequence -> statement SEMICOLON statement_sequence
Rule 41    statement_sequence -> statement
Rule 42    statement -> assignment_statement
Rule 43    statement -> statement_part
Rule 44    statement -> if_statement
Rule 45    statement -> while_statement
Rule 46    statement -> repeat_statement
Rule 47    statement -> for_statement
Rule 48    statement -> procedure_or_function_call
Rule 49    statement -> empty
Rule 50    procedure_or_function_call -> identifier
Rule 51    procedure_or_function_call -> identifier LPAREN param_list RPAREN
Rule 52    param_list -> param_list COMMA param
Rule 53    param_list -> param
Rule 54    param -> expression
Rule 55    if_statement -> IF expression THEN statement ELSE statement
Rule 56    if_statement -> IF expression THEN statement
Rule 57    while_statement -> WHILE expression DO statement
Rule 58    repeat_statement -> REPEAT statement UNTIL expression
Rule 59    for_statement -> FOR assignment_statement TO expression DO statement
Rule 60    for_statement -> FOR assignment_statement DOWNTO expression DO statement
Rule 61    assignment_statement -> identifier ASSIGNMENT expression
Rule 62    expression -> expression and_or expression_m
Rule 63    expression -> expression_m
Rule 64    expression_m -> expression_s
Rule 65    expression_m -> expression_m sign expression_s
Rule 66    expression_s -> element
Rule 67    expression_s -> expression_s psign element
Rule 68    and_or -> AND
Rule 69    and_or -> OR
Rule 70    psign -> TIMES
Rule 71    psign -> DIVISION
Rule 72    sign -> PLUS
Rule 73    sign -> MINUS
Rule 74    sign -> DIV
Rule 75    sign -> MOD
Rule 76    sign -> EQ
Rule 77    sign -> NEQ
Rule 78    sign -> LT
Rule 79    sign -> LTE
Rule 80    sign -> GT
Rule 81    sign -> GTE
Rule 82    element -> identifier
Rule 83    element -> identifier LBRACKET expression RBRACKET
Rule 84    element -> real
Rule 85    element -> integer
Rule 86    element -> string
Rule 87    element -> char
Rule 88    element -> boolean
Rule 89    element -> LPAREN expression RPAREN
Rule 90    element -> NOT element
Rule 91    element -> function_call_inline
Rule 92    function_call_inline -> identifier LPAREN param_list RPAREN
Rule 93    function_call_inline -> identifier LPAREN RPAREN
Rule 94    real -> REAL
Rule 95    integer -> INTEGER
Rule 96    string -> STRING
Rule 97    char -> CHAR
Rule 98    boolean -> TRUE
Rule 99    boolean -> FALSE

Terminals, with rules where they appear

AND                  : 68
ASSIGNMENT           : 61
BEGIN                : 39
CHAR                 : 97
COLON                : 11 23 24 25 31
COMMA                : 12 29 52
DIV                  : 74
DIVISION             : 71
DO                   : 57 59 60
DOT                  : 1
DOTDOT               : 38
DOWNTO               : 60
ELSE                 : 55
END                  : 39
EQ                   : 76
FALSE                : 99
FOR                  : 59 60
FUNCTION             : 22 23 24 25
GT                   : 80
GTE                  : 81
IDENTIFIER           : 14
IF                   : 55 56
INTEGER              : 95
LBRACKET             : 37 38 83
LPAREN               : 19 20 23 25 51 89 92 93
LT                   : 78
LTE                  : 79
MINUS                : 73
MOD                  : 75
NEQ                  : 77
NOT                  : 90
OF                   : 38
OR                   : 69
PLUS                 : 72
PROCEDURE            : 18 19 20
PROGRAM              : 2
RBRACKET             : 37 38 83
REAL                 : 94
REPEAT               : 58
RPAREN               : 19 20 23 25 51 89 92 93
SEMICOLON            : 1 6 7 11 17 21 40
STRING               : 96
TARRAY               : 38
TBOOLEAN             : 36
TCHAR                : 34
THEN                 : 55 56
TIMES                : 70
TINTEGER             : 33
TO                   : 59
TREAL                : 32
TRUE                 : 98
TSTRING              : 35 37
UNTIL                : 58
VAR                  : 8
WHILE                : 57
error                : 

Nonterminals, with rules where they appear

and_or               : 62
assignment_statement : 42 59 60
block                : 1 17 21
boolean              : 88
char                 : 87
element              : 66 67 90
empty                : 4 28 49
expression           : 54 55 56 57 58 59 60 61 62 83 89
expression_m         : 62 63 65
expression_s         : 64 65 67
for_statement        : 47
function_call_inline : 91
function_declaration : 16
function_heading     : 21
global_part          : 1
header               : 1
identifier           : 2 12 13 18 19 20 23 24 25 31 50 51 61 82 83 92 93
identifier_list      : 11 12
if_statement         : 44
integer              : 37 38 38 85
optional_vardec      : 26
param                : 52 53
param_list           : 51 52 92
parameter            : 29 30
parameter_list       : 20 25 29
procedure_declaration : 15
procedure_heading    : 17
procedure_or_function_call : 48
program              : 0
psign                : 67
real                 : 84
repeat_statement     : 46
sign                 : 65
statement            : 40 41 55 55 56 57 58 59 60
statement_part       : 26 43
statement_sequence   : 39 40
string               : 86
sub_declaration      : 6 7
sub_declaration_list : 3 6
type                 : 11 22 23 24 25 31 38
variable_declaration : 9 10
variable_declaration_list : 8 9
variable_declaration_part : 27
while_statement      : 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header SEMICOLON global_part block DOT
    (2) header -> . PROGRAM identifier

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . SEMICOLON global_part block DOT

    SEMICOLON       shift and go to state 4


state 3

    (2) header -> PROGRAM . identifier
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    identifier                     shift and go to state 5

state 4

    (1) program -> header SEMICOLON . global_part block DOT
    (3) global_part -> . sub_declaration_list
    (4) global_part -> . empty
    (6) sub_declaration_list -> . sub_declaration SEMICOLON sub_declaration_list
    (7) sub_declaration_list -> . sub_declaration SEMICOLON
    (5) empty -> .
    (15) sub_declaration -> . procedure_declaration
    (16) sub_declaration -> . function_declaration
    (17) procedure_declaration -> . procedure_heading SEMICOLON block
    (21) function_declaration -> . function_heading SEMICOLON block
    (18) procedure_heading -> . PROCEDURE identifier
    (19) procedure_heading -> . PROCEDURE identifier LPAREN RPAREN
    (20) procedure_heading -> . PROCEDURE identifier LPAREN parameter_list RPAREN
    (22) function_heading -> . FUNCTION type
    (23) function_heading -> . FUNCTION identifier LPAREN RPAREN COLON type
    (24) function_heading -> . FUNCTION identifier COLON type
    (25) function_heading -> . FUNCTION identifier LPAREN parameter_list RPAREN COLON type

    VAR             reduce using rule 5 (empty -> .)
    BEGIN           reduce using rule 5 (empty -> .)
    PROCEDURE       shift and go to state 15
    FUNCTION        shift and go to state 16

    global_part                    shift and go to state 7
    sub_declaration_list           shift and go to state 8
    empty                          shift and go to state 9
    sub_declaration                shift and go to state 10
    procedure_declaration          shift and go to state 11
    function_declaration           shift and go to state 12
    procedure_heading              shift and go to state 13
    function_heading               shift and go to state 14

state 5

    (2) header -> PROGRAM identifier .

    SEMICOLON       reduce using rule 2 (header -> PROGRAM identifier .)


state 6

    (14) identifier -> IDENTIFIER .

    SEMICOLON       reduce using rule 14 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 14 (identifier -> IDENTIFIER .)
    COLON           reduce using rule 14 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 14 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 14 (identifier -> IDENTIFIER .)
    END             reduce using rule 14 (identifier -> IDENTIFIER .)
    LBRACKET        reduce using rule 14 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 14 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 14 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 14 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 14 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 14 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 14 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 14 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 14 (identifier -> IDENTIFIER .)
    LT              reduce using rule 14 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 14 (identifier -> IDENTIFIER .)
    GT              reduce using rule 14 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 14 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 14 (identifier -> IDENTIFIER .)
    AND             reduce using rule 14 (identifier -> IDENTIFIER .)
    OR              reduce using rule 14 (identifier -> IDENTIFIER .)
    DO              reduce using rule 14 (identifier -> IDENTIFIER .)
    UNTIL           reduce using rule 14 (identifier -> IDENTIFIER .)
    TO              reduce using rule 14 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 14 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 14 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 14 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 14 (identifier -> IDENTIFIER .)


state 7

    (1) program -> header SEMICOLON global_part . block DOT
    (26) block -> . optional_vardec statement_part
    (27) optional_vardec -> . variable_declaration_part
    (28) optional_vardec -> . empty
    (8) variable_declaration_part -> . VAR variable_declaration_list
    (5) empty -> .

    VAR             shift and go to state 21
    BEGIN           reduce using rule 5 (empty -> .)

    block                          shift and go to state 17
    optional_vardec                shift and go to state 18
    variable_declaration_part      shift and go to state 19
    empty                          shift and go to state 20

state 8

    (3) global_part -> sub_declaration_list .

    VAR             reduce using rule 3 (global_part -> sub_declaration_list .)
    BEGIN           reduce using rule 3 (global_part -> sub_declaration_list .)


state 9

    (4) global_part -> empty .

    VAR             reduce using rule 4 (global_part -> empty .)
    BEGIN           reduce using rule 4 (global_part -> empty .)


state 10

    (6) sub_declaration_list -> sub_declaration . SEMICOLON sub_declaration_list
    (7) sub_declaration_list -> sub_declaration . SEMICOLON

    SEMICOLON       shift and go to state 22


state 11

    (15) sub_declaration -> procedure_declaration .

    SEMICOLON       reduce using rule 15 (sub_declaration -> procedure_declaration .)


state 12

    (16) sub_declaration -> function_declaration .

    SEMICOLON       reduce using rule 16 (sub_declaration -> function_declaration .)


state 13

    (17) procedure_declaration -> procedure_heading . SEMICOLON block

    SEMICOLON       shift and go to state 23


state 14

    (21) function_declaration -> function_heading . SEMICOLON block

    SEMICOLON       shift and go to state 24


state 15

    (18) procedure_heading -> PROCEDURE . identifier
    (19) procedure_heading -> PROCEDURE . identifier LPAREN RPAREN
    (20) procedure_heading -> PROCEDURE . identifier LPAREN parameter_list RPAREN
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    identifier                     shift and go to state 25

state 16

    (22) function_heading -> FUNCTION . type
    (23) function_heading -> FUNCTION . identifier LPAREN RPAREN COLON type
    (24) function_heading -> FUNCTION . identifier COLON type
    (25) function_heading -> FUNCTION . identifier LPAREN parameter_list RPAREN COLON type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type
    (14) identifier -> . IDENTIFIER

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33
    IDENTIFIER      shift and go to state 6

    type                           shift and go to state 26
    identifier                     shift and go to state 27

state 17

    (1) program -> header SEMICOLON global_part block . DOT

    DOT             shift and go to state 34


state 18

    (26) block -> optional_vardec . statement_part
    (39) statement_part -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 36

    statement_part                 shift and go to state 35

state 19

    (27) optional_vardec -> variable_declaration_part .

    BEGIN           reduce using rule 27 (optional_vardec -> variable_declaration_part .)


state 20

    (28) optional_vardec -> empty .

    BEGIN           reduce using rule 28 (optional_vardec -> empty .)


state 21

    (8) variable_declaration_part -> VAR . variable_declaration_list
    (9) variable_declaration_list -> . variable_declaration variable_declaration_list
    (10) variable_declaration_list -> . variable_declaration
    (11) variable_declaration -> . identifier_list COLON type SEMICOLON
    (12) identifier_list -> . identifier COMMA identifier_list
    (13) identifier_list -> . identifier
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    variable_declaration_list      shift and go to state 37
    variable_declaration           shift and go to state 38
    identifier_list                shift and go to state 39
    identifier                     shift and go to state 40

state 22

    (6) sub_declaration_list -> sub_declaration SEMICOLON . sub_declaration_list
    (7) sub_declaration_list -> sub_declaration SEMICOLON .
    (6) sub_declaration_list -> . sub_declaration SEMICOLON sub_declaration_list
    (7) sub_declaration_list -> . sub_declaration SEMICOLON
    (15) sub_declaration -> . procedure_declaration
    (16) sub_declaration -> . function_declaration
    (17) procedure_declaration -> . procedure_heading SEMICOLON block
    (21) function_declaration -> . function_heading SEMICOLON block
    (18) procedure_heading -> . PROCEDURE identifier
    (19) procedure_heading -> . PROCEDURE identifier LPAREN RPAREN
    (20) procedure_heading -> . PROCEDURE identifier LPAREN parameter_list RPAREN
    (22) function_heading -> . FUNCTION type
    (23) function_heading -> . FUNCTION identifier LPAREN RPAREN COLON type
    (24) function_heading -> . FUNCTION identifier COLON type
    (25) function_heading -> . FUNCTION identifier LPAREN parameter_list RPAREN COLON type

    VAR             reduce using rule 7 (sub_declaration_list -> sub_declaration SEMICOLON .)
    BEGIN           reduce using rule 7 (sub_declaration_list -> sub_declaration SEMICOLON .)
    PROCEDURE       shift and go to state 15
    FUNCTION        shift and go to state 16

    sub_declaration                shift and go to state 10
    sub_declaration_list           shift and go to state 41
    procedure_declaration          shift and go to state 11
    function_declaration           shift and go to state 12
    procedure_heading              shift and go to state 13
    function_heading               shift and go to state 14

state 23

    (17) procedure_declaration -> procedure_heading SEMICOLON . block
    (26) block -> . optional_vardec statement_part
    (27) optional_vardec -> . variable_declaration_part
    (28) optional_vardec -> . empty
    (8) variable_declaration_part -> . VAR variable_declaration_list
    (5) empty -> .

    VAR             shift and go to state 21
    BEGIN           reduce using rule 5 (empty -> .)

    block                          shift and go to state 42
    optional_vardec                shift and go to state 18
    variable_declaration_part      shift and go to state 19
    empty                          shift and go to state 20

state 24

    (21) function_declaration -> function_heading SEMICOLON . block
    (26) block -> . optional_vardec statement_part
    (27) optional_vardec -> . variable_declaration_part
    (28) optional_vardec -> . empty
    (8) variable_declaration_part -> . VAR variable_declaration_list
    (5) empty -> .

    VAR             shift and go to state 21
    BEGIN           reduce using rule 5 (empty -> .)

    block                          shift and go to state 43
    optional_vardec                shift and go to state 18
    variable_declaration_part      shift and go to state 19
    empty                          shift and go to state 20

state 25

    (18) procedure_heading -> PROCEDURE identifier .
    (19) procedure_heading -> PROCEDURE identifier . LPAREN RPAREN
    (20) procedure_heading -> PROCEDURE identifier . LPAREN parameter_list RPAREN

    SEMICOLON       reduce using rule 18 (procedure_heading -> PROCEDURE identifier .)
    LPAREN          shift and go to state 44


state 26

    (22) function_heading -> FUNCTION type .

    SEMICOLON       reduce using rule 22 (function_heading -> FUNCTION type .)


state 27

    (23) function_heading -> FUNCTION identifier . LPAREN RPAREN COLON type
    (24) function_heading -> FUNCTION identifier . COLON type
    (25) function_heading -> FUNCTION identifier . LPAREN parameter_list RPAREN COLON type

    LPAREN          shift and go to state 45
    COLON           shift and go to state 46


state 28

    (32) type -> TREAL .

    SEMICOLON       reduce using rule 32 (type -> TREAL .)
    COMMA           reduce using rule 32 (type -> TREAL .)
    RPAREN          reduce using rule 32 (type -> TREAL .)


state 29

    (33) type -> TINTEGER .

    SEMICOLON       reduce using rule 33 (type -> TINTEGER .)
    COMMA           reduce using rule 33 (type -> TINTEGER .)
    RPAREN          reduce using rule 33 (type -> TINTEGER .)


state 30

    (34) type -> TCHAR .

    SEMICOLON       reduce using rule 34 (type -> TCHAR .)
    COMMA           reduce using rule 34 (type -> TCHAR .)
    RPAREN          reduce using rule 34 (type -> TCHAR .)


state 31

    (35) type -> TSTRING .
    (37) type -> TSTRING . LBRACKET integer RBRACKET

    SEMICOLON       reduce using rule 35 (type -> TSTRING .)
    COMMA           reduce using rule 35 (type -> TSTRING .)
    RPAREN          reduce using rule 35 (type -> TSTRING .)
    LBRACKET        shift and go to state 47


state 32

    (36) type -> TBOOLEAN .

    SEMICOLON       reduce using rule 36 (type -> TBOOLEAN .)
    COMMA           reduce using rule 36 (type -> TBOOLEAN .)
    RPAREN          reduce using rule 36 (type -> TBOOLEAN .)


state 33

    (38) type -> TARRAY . LBRACKET integer DOTDOT integer RBRACKET OF type

    LBRACKET        shift and go to state 48


state 34

    (1) program -> header SEMICOLON global_part block DOT .

    $end            reduce using rule 1 (program -> header SEMICOLON global_part block DOT .)


state 35

    (26) block -> optional_vardec statement_part .

    DOT             reduce using rule 26 (block -> optional_vardec statement_part .)
    SEMICOLON       reduce using rule 26 (block -> optional_vardec statement_part .)


state 36

    (39) statement_part -> BEGIN . statement_sequence END
    (40) statement_sequence -> . statement SEMICOLON statement_sequence
    (41) statement_sequence -> . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement_sequence             shift and go to state 49
    statement                      shift and go to state 50
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 37

    (8) variable_declaration_part -> VAR variable_declaration_list .

    BEGIN           reduce using rule 8 (variable_declaration_part -> VAR variable_declaration_list .)


state 38

    (9) variable_declaration_list -> variable_declaration . variable_declaration_list
    (10) variable_declaration_list -> variable_declaration .
    (9) variable_declaration_list -> . variable_declaration variable_declaration_list
    (10) variable_declaration_list -> . variable_declaration
    (11) variable_declaration -> . identifier_list COLON type SEMICOLON
    (12) identifier_list -> . identifier COMMA identifier_list
    (13) identifier_list -> . identifier
    (14) identifier -> . IDENTIFIER

    BEGIN           reduce using rule 10 (variable_declaration_list -> variable_declaration .)
    IDENTIFIER      shift and go to state 6

    variable_declaration           shift and go to state 38
    variable_declaration_list      shift and go to state 64
    identifier_list                shift and go to state 39
    identifier                     shift and go to state 40

state 39

    (11) variable_declaration -> identifier_list . COLON type SEMICOLON

    COLON           shift and go to state 65


state 40

    (12) identifier_list -> identifier . COMMA identifier_list
    (13) identifier_list -> identifier .

    COMMA           shift and go to state 66
    COLON           reduce using rule 13 (identifier_list -> identifier .)


state 41

    (6) sub_declaration_list -> sub_declaration SEMICOLON sub_declaration_list .

    VAR             reduce using rule 6 (sub_declaration_list -> sub_declaration SEMICOLON sub_declaration_list .)
    BEGIN           reduce using rule 6 (sub_declaration_list -> sub_declaration SEMICOLON sub_declaration_list .)


state 42

    (17) procedure_declaration -> procedure_heading SEMICOLON block .

    SEMICOLON       reduce using rule 17 (procedure_declaration -> procedure_heading SEMICOLON block .)


state 43

    (21) function_declaration -> function_heading SEMICOLON block .

    SEMICOLON       reduce using rule 21 (function_declaration -> function_heading SEMICOLON block .)


state 44

    (19) procedure_heading -> PROCEDURE identifier LPAREN . RPAREN
    (20) procedure_heading -> PROCEDURE identifier LPAREN . parameter_list RPAREN
    (29) parameter_list -> . parameter COMMA parameter_list
    (30) parameter_list -> . parameter
    (31) parameter -> . identifier COLON type
    (14) identifier -> . IDENTIFIER

    RPAREN          shift and go to state 68
    IDENTIFIER      shift and go to state 6

    identifier                     shift and go to state 67
    parameter_list                 shift and go to state 69
    parameter                      shift and go to state 70

state 45

    (23) function_heading -> FUNCTION identifier LPAREN . RPAREN COLON type
    (25) function_heading -> FUNCTION identifier LPAREN . parameter_list RPAREN COLON type
    (29) parameter_list -> . parameter COMMA parameter_list
    (30) parameter_list -> . parameter
    (31) parameter -> . identifier COLON type
    (14) identifier -> . IDENTIFIER

    RPAREN          shift and go to state 71
    IDENTIFIER      shift and go to state 6

    identifier                     shift and go to state 67
    parameter_list                 shift and go to state 72
    parameter                      shift and go to state 70

state 46

    (24) function_heading -> FUNCTION identifier COLON . type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 73

state 47

    (37) type -> TSTRING LBRACKET . integer RBRACKET
    (95) integer -> . INTEGER

    INTEGER         shift and go to state 75

    integer                        shift and go to state 74

state 48

    (38) type -> TARRAY LBRACKET . integer DOTDOT integer RBRACKET OF type
    (95) integer -> . INTEGER

    INTEGER         shift and go to state 75

    integer                        shift and go to state 76

state 49

    (39) statement_part -> BEGIN statement_sequence . END

    END             shift and go to state 77


state 50

    (40) statement_sequence -> statement . SEMICOLON statement_sequence
    (41) statement_sequence -> statement .

    SEMICOLON       shift and go to state 78
    END             reduce using rule 41 (statement_sequence -> statement .)


state 51

    (42) statement -> assignment_statement .

    SEMICOLON       reduce using rule 42 (statement -> assignment_statement .)
    END             reduce using rule 42 (statement -> assignment_statement .)
    UNTIL           reduce using rule 42 (statement -> assignment_statement .)
    ELSE            reduce using rule 42 (statement -> assignment_statement .)


state 52

    (43) statement -> statement_part .

    SEMICOLON       reduce using rule 43 (statement -> statement_part .)
    END             reduce using rule 43 (statement -> statement_part .)
    UNTIL           reduce using rule 43 (statement -> statement_part .)
    ELSE            reduce using rule 43 (statement -> statement_part .)


state 53

    (44) statement -> if_statement .

    SEMICOLON       reduce using rule 44 (statement -> if_statement .)
    END             reduce using rule 44 (statement -> if_statement .)
    UNTIL           reduce using rule 44 (statement -> if_statement .)
    ELSE            reduce using rule 44 (statement -> if_statement .)


state 54

    (45) statement -> while_statement .

    SEMICOLON       reduce using rule 45 (statement -> while_statement .)
    END             reduce using rule 45 (statement -> while_statement .)
    UNTIL           reduce using rule 45 (statement -> while_statement .)
    ELSE            reduce using rule 45 (statement -> while_statement .)


state 55

    (46) statement -> repeat_statement .

    SEMICOLON       reduce using rule 46 (statement -> repeat_statement .)
    END             reduce using rule 46 (statement -> repeat_statement .)
    UNTIL           reduce using rule 46 (statement -> repeat_statement .)
    ELSE            reduce using rule 46 (statement -> repeat_statement .)


state 56

    (47) statement -> for_statement .

    SEMICOLON       reduce using rule 47 (statement -> for_statement .)
    END             reduce using rule 47 (statement -> for_statement .)
    UNTIL           reduce using rule 47 (statement -> for_statement .)
    ELSE            reduce using rule 47 (statement -> for_statement .)


state 57

    (48) statement -> procedure_or_function_call .

    SEMICOLON       reduce using rule 48 (statement -> procedure_or_function_call .)
    END             reduce using rule 48 (statement -> procedure_or_function_call .)
    UNTIL           reduce using rule 48 (statement -> procedure_or_function_call .)
    ELSE            reduce using rule 48 (statement -> procedure_or_function_call .)


state 58

    (49) statement -> empty .

    SEMICOLON       reduce using rule 49 (statement -> empty .)
    END             reduce using rule 49 (statement -> empty .)
    UNTIL           reduce using rule 49 (statement -> empty .)
    ELSE            reduce using rule 49 (statement -> empty .)


state 59

    (61) assignment_statement -> identifier . ASSIGNMENT expression
    (50) procedure_or_function_call -> identifier .
    (51) procedure_or_function_call -> identifier . LPAREN param_list RPAREN

    ASSIGNMENT      shift and go to state 79
    SEMICOLON       reduce using rule 50 (procedure_or_function_call -> identifier .)
    END             reduce using rule 50 (procedure_or_function_call -> identifier .)
    UNTIL           reduce using rule 50 (procedure_or_function_call -> identifier .)
    ELSE            reduce using rule 50 (procedure_or_function_call -> identifier .)
    LPAREN          shift and go to state 80


state 60

    (55) if_statement -> IF . expression THEN statement ELSE statement
    (56) if_statement -> IF . expression THEN statement
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 81
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 61

    (57) while_statement -> WHILE . expression DO statement
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 99
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 62

    (58) repeat_statement -> REPEAT . statement UNTIL expression
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement                      shift and go to state 100
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 63

    (59) for_statement -> FOR . assignment_statement TO expression DO statement
    (60) for_statement -> FOR . assignment_statement DOWNTO expression DO statement
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    assignment_statement           shift and go to state 101
    identifier                     shift and go to state 102

state 64

    (9) variable_declaration_list -> variable_declaration variable_declaration_list .

    BEGIN           reduce using rule 9 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 65

    (11) variable_declaration -> identifier_list COLON . type SEMICOLON
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 103

state 66

    (12) identifier_list -> identifier COMMA . identifier_list
    (12) identifier_list -> . identifier COMMA identifier_list
    (13) identifier_list -> . identifier
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    identifier                     shift and go to state 40
    identifier_list                shift and go to state 104

state 67

    (31) parameter -> identifier . COLON type

    COLON           shift and go to state 105


state 68

    (19) procedure_heading -> PROCEDURE identifier LPAREN RPAREN .

    SEMICOLON       reduce using rule 19 (procedure_heading -> PROCEDURE identifier LPAREN RPAREN .)


state 69

    (20) procedure_heading -> PROCEDURE identifier LPAREN parameter_list . RPAREN

    RPAREN          shift and go to state 106


state 70

    (29) parameter_list -> parameter . COMMA parameter_list
    (30) parameter_list -> parameter .

    COMMA           shift and go to state 107
    RPAREN          reduce using rule 30 (parameter_list -> parameter .)


state 71

    (23) function_heading -> FUNCTION identifier LPAREN RPAREN . COLON type

    COLON           shift and go to state 108


state 72

    (25) function_heading -> FUNCTION identifier LPAREN parameter_list . RPAREN COLON type

    RPAREN          shift and go to state 109


state 73

    (24) function_heading -> FUNCTION identifier COLON type .

    SEMICOLON       reduce using rule 24 (function_heading -> FUNCTION identifier COLON type .)


state 74

    (37) type -> TSTRING LBRACKET integer . RBRACKET

    RBRACKET        shift and go to state 110


state 75

    (95) integer -> INTEGER .

    RBRACKET        reduce using rule 95 (integer -> INTEGER .)
    DOTDOT          reduce using rule 95 (integer -> INTEGER .)
    TIMES           reduce using rule 95 (integer -> INTEGER .)
    DIVISION        reduce using rule 95 (integer -> INTEGER .)
    PLUS            reduce using rule 95 (integer -> INTEGER .)
    MINUS           reduce using rule 95 (integer -> INTEGER .)
    DIV             reduce using rule 95 (integer -> INTEGER .)
    MOD             reduce using rule 95 (integer -> INTEGER .)
    EQ              reduce using rule 95 (integer -> INTEGER .)
    NEQ             reduce using rule 95 (integer -> INTEGER .)
    LT              reduce using rule 95 (integer -> INTEGER .)
    LTE             reduce using rule 95 (integer -> INTEGER .)
    GT              reduce using rule 95 (integer -> INTEGER .)
    GTE             reduce using rule 95 (integer -> INTEGER .)
    THEN            reduce using rule 95 (integer -> INTEGER .)
    AND             reduce using rule 95 (integer -> INTEGER .)
    OR              reduce using rule 95 (integer -> INTEGER .)
    DO              reduce using rule 95 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 95 (integer -> INTEGER .)
    END             reduce using rule 95 (integer -> INTEGER .)
    UNTIL           reduce using rule 95 (integer -> INTEGER .)
    TO              reduce using rule 95 (integer -> INTEGER .)
    DOWNTO          reduce using rule 95 (integer -> INTEGER .)
    ELSE            reduce using rule 95 (integer -> INTEGER .)
    RPAREN          reduce using rule 95 (integer -> INTEGER .)
    COMMA           reduce using rule 95 (integer -> INTEGER .)


state 76

    (38) type -> TARRAY LBRACKET integer . DOTDOT integer RBRACKET OF type

    DOTDOT          shift and go to state 111


state 77

    (39) statement_part -> BEGIN statement_sequence END .

    DOT             reduce using rule 39 (statement_part -> BEGIN statement_sequence END .)
    SEMICOLON       reduce using rule 39 (statement_part -> BEGIN statement_sequence END .)
    END             reduce using rule 39 (statement_part -> BEGIN statement_sequence END .)
    UNTIL           reduce using rule 39 (statement_part -> BEGIN statement_sequence END .)
    ELSE            reduce using rule 39 (statement_part -> BEGIN statement_sequence END .)


state 78

    (40) statement_sequence -> statement SEMICOLON . statement_sequence
    (40) statement_sequence -> . statement SEMICOLON statement_sequence
    (41) statement_sequence -> . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement                      shift and go to state 50
    statement_sequence             shift and go to state 112
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 79

    (61) assignment_statement -> identifier ASSIGNMENT . expression
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    identifier                     shift and go to state 85
    expression                     shift and go to state 113
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 80

    (51) procedure_or_function_call -> identifier LPAREN . param_list RPAREN
    (52) param_list -> . param_list COMMA param
    (53) param_list -> . param
    (54) param -> . expression
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    identifier                     shift and go to state 85
    param_list                     shift and go to state 114
    param                          shift and go to state 115
    expression                     shift and go to state 116
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 81

    (55) if_statement -> IF expression . THEN statement ELSE statement
    (56) if_statement -> IF expression . THEN statement
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    THEN            shift and go to state 117
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 82

    (63) expression -> expression_m .
    (65) expression_m -> expression_m . sign expression_s
    (72) sign -> . PLUS
    (73) sign -> . MINUS
    (74) sign -> . DIV
    (75) sign -> . MOD
    (76) sign -> . EQ
    (77) sign -> . NEQ
    (78) sign -> . LT
    (79) sign -> . LTE
    (80) sign -> . GT
    (81) sign -> . GTE

    THEN            reduce using rule 63 (expression -> expression_m .)
    AND             reduce using rule 63 (expression -> expression_m .)
    OR              reduce using rule 63 (expression -> expression_m .)
    DO              reduce using rule 63 (expression -> expression_m .)
    SEMICOLON       reduce using rule 63 (expression -> expression_m .)
    END             reduce using rule 63 (expression -> expression_m .)
    UNTIL           reduce using rule 63 (expression -> expression_m .)
    TO              reduce using rule 63 (expression -> expression_m .)
    DOWNTO          reduce using rule 63 (expression -> expression_m .)
    ELSE            reduce using rule 63 (expression -> expression_m .)
    RPAREN          reduce using rule 63 (expression -> expression_m .)
    COMMA           reduce using rule 63 (expression -> expression_m .)
    RBRACKET        reduce using rule 63 (expression -> expression_m .)
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    DIV             shift and go to state 124
    MOD             shift and go to state 125
    EQ              shift and go to state 126
    NEQ             shift and go to state 127
    LT              shift and go to state 128
    LTE             shift and go to state 129
    GT              shift and go to state 130
    GTE             shift and go to state 131

    sign                           shift and go to state 121

state 83

    (64) expression_m -> expression_s .
    (67) expression_s -> expression_s . psign element
    (70) psign -> . TIMES
    (71) psign -> . DIVISION

    PLUS            reduce using rule 64 (expression_m -> expression_s .)
    MINUS           reduce using rule 64 (expression_m -> expression_s .)
    DIV             reduce using rule 64 (expression_m -> expression_s .)
    MOD             reduce using rule 64 (expression_m -> expression_s .)
    EQ              reduce using rule 64 (expression_m -> expression_s .)
    NEQ             reduce using rule 64 (expression_m -> expression_s .)
    LT              reduce using rule 64 (expression_m -> expression_s .)
    LTE             reduce using rule 64 (expression_m -> expression_s .)
    GT              reduce using rule 64 (expression_m -> expression_s .)
    GTE             reduce using rule 64 (expression_m -> expression_s .)
    THEN            reduce using rule 64 (expression_m -> expression_s .)
    AND             reduce using rule 64 (expression_m -> expression_s .)
    OR              reduce using rule 64 (expression_m -> expression_s .)
    DO              reduce using rule 64 (expression_m -> expression_s .)
    SEMICOLON       reduce using rule 64 (expression_m -> expression_s .)
    END             reduce using rule 64 (expression_m -> expression_s .)
    UNTIL           reduce using rule 64 (expression_m -> expression_s .)
    TO              reduce using rule 64 (expression_m -> expression_s .)
    DOWNTO          reduce using rule 64 (expression_m -> expression_s .)
    ELSE            reduce using rule 64 (expression_m -> expression_s .)
    RPAREN          reduce using rule 64 (expression_m -> expression_s .)
    COMMA           reduce using rule 64 (expression_m -> expression_s .)
    RBRACKET        reduce using rule 64 (expression_m -> expression_s .)
    TIMES           shift and go to state 133
    DIVISION        shift and go to state 134

    psign                          shift and go to state 132

state 84

    (66) expression_s -> element .

    TIMES           reduce using rule 66 (expression_s -> element .)
    DIVISION        reduce using rule 66 (expression_s -> element .)
    PLUS            reduce using rule 66 (expression_s -> element .)
    MINUS           reduce using rule 66 (expression_s -> element .)
    DIV             reduce using rule 66 (expression_s -> element .)
    MOD             reduce using rule 66 (expression_s -> element .)
    EQ              reduce using rule 66 (expression_s -> element .)
    NEQ             reduce using rule 66 (expression_s -> element .)
    LT              reduce using rule 66 (expression_s -> element .)
    LTE             reduce using rule 66 (expression_s -> element .)
    GT              reduce using rule 66 (expression_s -> element .)
    GTE             reduce using rule 66 (expression_s -> element .)
    THEN            reduce using rule 66 (expression_s -> element .)
    AND             reduce using rule 66 (expression_s -> element .)
    OR              reduce using rule 66 (expression_s -> element .)
    DO              reduce using rule 66 (expression_s -> element .)
    SEMICOLON       reduce using rule 66 (expression_s -> element .)
    END             reduce using rule 66 (expression_s -> element .)
    UNTIL           reduce using rule 66 (expression_s -> element .)
    TO              reduce using rule 66 (expression_s -> element .)
    DOWNTO          reduce using rule 66 (expression_s -> element .)
    ELSE            reduce using rule 66 (expression_s -> element .)
    RPAREN          reduce using rule 66 (expression_s -> element .)
    COMMA           reduce using rule 66 (expression_s -> element .)
    RBRACKET        reduce using rule 66 (expression_s -> element .)


state 85

    (82) element -> identifier .
    (83) element -> identifier . LBRACKET expression RBRACKET
    (92) function_call_inline -> identifier . LPAREN param_list RPAREN
    (93) function_call_inline -> identifier . LPAREN RPAREN

    TIMES           reduce using rule 82 (element -> identifier .)
    DIVISION        reduce using rule 82 (element -> identifier .)
    PLUS            reduce using rule 82 (element -> identifier .)
    MINUS           reduce using rule 82 (element -> identifier .)
    DIV             reduce using rule 82 (element -> identifier .)
    MOD             reduce using rule 82 (element -> identifier .)
    EQ              reduce using rule 82 (element -> identifier .)
    NEQ             reduce using rule 82 (element -> identifier .)
    LT              reduce using rule 82 (element -> identifier .)
    LTE             reduce using rule 82 (element -> identifier .)
    GT              reduce using rule 82 (element -> identifier .)
    GTE             reduce using rule 82 (element -> identifier .)
    THEN            reduce using rule 82 (element -> identifier .)
    AND             reduce using rule 82 (element -> identifier .)
    OR              reduce using rule 82 (element -> identifier .)
    DO              reduce using rule 82 (element -> identifier .)
    SEMICOLON       reduce using rule 82 (element -> identifier .)
    END             reduce using rule 82 (element -> identifier .)
    UNTIL           reduce using rule 82 (element -> identifier .)
    TO              reduce using rule 82 (element -> identifier .)
    DOWNTO          reduce using rule 82 (element -> identifier .)
    ELSE            reduce using rule 82 (element -> identifier .)
    RPAREN          reduce using rule 82 (element -> identifier .)
    COMMA           reduce using rule 82 (element -> identifier .)
    RBRACKET        reduce using rule 82 (element -> identifier .)
    LBRACKET        shift and go to state 135
    LPAREN          shift and go to state 136


state 86

    (84) element -> real .

    TIMES           reduce using rule 84 (element -> real .)
    DIVISION        reduce using rule 84 (element -> real .)
    PLUS            reduce using rule 84 (element -> real .)
    MINUS           reduce using rule 84 (element -> real .)
    DIV             reduce using rule 84 (element -> real .)
    MOD             reduce using rule 84 (element -> real .)
    EQ              reduce using rule 84 (element -> real .)
    NEQ             reduce using rule 84 (element -> real .)
    LT              reduce using rule 84 (element -> real .)
    LTE             reduce using rule 84 (element -> real .)
    GT              reduce using rule 84 (element -> real .)
    GTE             reduce using rule 84 (element -> real .)
    THEN            reduce using rule 84 (element -> real .)
    AND             reduce using rule 84 (element -> real .)
    OR              reduce using rule 84 (element -> real .)
    DO              reduce using rule 84 (element -> real .)
    SEMICOLON       reduce using rule 84 (element -> real .)
    END             reduce using rule 84 (element -> real .)
    UNTIL           reduce using rule 84 (element -> real .)
    TO              reduce using rule 84 (element -> real .)
    DOWNTO          reduce using rule 84 (element -> real .)
    ELSE            reduce using rule 84 (element -> real .)
    RPAREN          reduce using rule 84 (element -> real .)
    COMMA           reduce using rule 84 (element -> real .)
    RBRACKET        reduce using rule 84 (element -> real .)


state 87

    (85) element -> integer .

    TIMES           reduce using rule 85 (element -> integer .)
    DIVISION        reduce using rule 85 (element -> integer .)
    PLUS            reduce using rule 85 (element -> integer .)
    MINUS           reduce using rule 85 (element -> integer .)
    DIV             reduce using rule 85 (element -> integer .)
    MOD             reduce using rule 85 (element -> integer .)
    EQ              reduce using rule 85 (element -> integer .)
    NEQ             reduce using rule 85 (element -> integer .)
    LT              reduce using rule 85 (element -> integer .)
    LTE             reduce using rule 85 (element -> integer .)
    GT              reduce using rule 85 (element -> integer .)
    GTE             reduce using rule 85 (element -> integer .)
    THEN            reduce using rule 85 (element -> integer .)
    AND             reduce using rule 85 (element -> integer .)
    OR              reduce using rule 85 (element -> integer .)
    DO              reduce using rule 85 (element -> integer .)
    SEMICOLON       reduce using rule 85 (element -> integer .)
    END             reduce using rule 85 (element -> integer .)
    UNTIL           reduce using rule 85 (element -> integer .)
    TO              reduce using rule 85 (element -> integer .)
    DOWNTO          reduce using rule 85 (element -> integer .)
    ELSE            reduce using rule 85 (element -> integer .)
    RPAREN          reduce using rule 85 (element -> integer .)
    COMMA           reduce using rule 85 (element -> integer .)
    RBRACKET        reduce using rule 85 (element -> integer .)


state 88

    (86) element -> string .

    TIMES           reduce using rule 86 (element -> string .)
    DIVISION        reduce using rule 86 (element -> string .)
    PLUS            reduce using rule 86 (element -> string .)
    MINUS           reduce using rule 86 (element -> string .)
    DIV             reduce using rule 86 (element -> string .)
    MOD             reduce using rule 86 (element -> string .)
    EQ              reduce using rule 86 (element -> string .)
    NEQ             reduce using rule 86 (element -> string .)
    LT              reduce using rule 86 (element -> string .)
    LTE             reduce using rule 86 (element -> string .)
    GT              reduce using rule 86 (element -> string .)
    GTE             reduce using rule 86 (element -> string .)
    THEN            reduce using rule 86 (element -> string .)
    AND             reduce using rule 86 (element -> string .)
    OR              reduce using rule 86 (element -> string .)
    DO              reduce using rule 86 (element -> string .)
    SEMICOLON       reduce using rule 86 (element -> string .)
    END             reduce using rule 86 (element -> string .)
    UNTIL           reduce using rule 86 (element -> string .)
    TO              reduce using rule 86 (element -> string .)
    DOWNTO          reduce using rule 86 (element -> string .)
    ELSE            reduce using rule 86 (element -> string .)
    RPAREN          reduce using rule 86 (element -> string .)
    COMMA           reduce using rule 86 (element -> string .)
    RBRACKET        reduce using rule 86 (element -> string .)


state 89

    (87) element -> char .

    TIMES           reduce using rule 87 (element -> char .)
    DIVISION        reduce using rule 87 (element -> char .)
    PLUS            reduce using rule 87 (element -> char .)
    MINUS           reduce using rule 87 (element -> char .)
    DIV             reduce using rule 87 (element -> char .)
    MOD             reduce using rule 87 (element -> char .)
    EQ              reduce using rule 87 (element -> char .)
    NEQ             reduce using rule 87 (element -> char .)
    LT              reduce using rule 87 (element -> char .)
    LTE             reduce using rule 87 (element -> char .)
    GT              reduce using rule 87 (element -> char .)
    GTE             reduce using rule 87 (element -> char .)
    THEN            reduce using rule 87 (element -> char .)
    AND             reduce using rule 87 (element -> char .)
    OR              reduce using rule 87 (element -> char .)
    DO              reduce using rule 87 (element -> char .)
    SEMICOLON       reduce using rule 87 (element -> char .)
    END             reduce using rule 87 (element -> char .)
    UNTIL           reduce using rule 87 (element -> char .)
    TO              reduce using rule 87 (element -> char .)
    DOWNTO          reduce using rule 87 (element -> char .)
    ELSE            reduce using rule 87 (element -> char .)
    RPAREN          reduce using rule 87 (element -> char .)
    COMMA           reduce using rule 87 (element -> char .)
    RBRACKET        reduce using rule 87 (element -> char .)


state 90

    (88) element -> boolean .

    TIMES           reduce using rule 88 (element -> boolean .)
    DIVISION        reduce using rule 88 (element -> boolean .)
    PLUS            reduce using rule 88 (element -> boolean .)
    MINUS           reduce using rule 88 (element -> boolean .)
    DIV             reduce using rule 88 (element -> boolean .)
    MOD             reduce using rule 88 (element -> boolean .)
    EQ              reduce using rule 88 (element -> boolean .)
    NEQ             reduce using rule 88 (element -> boolean .)
    LT              reduce using rule 88 (element -> boolean .)
    LTE             reduce using rule 88 (element -> boolean .)
    GT              reduce using rule 88 (element -> boolean .)
    GTE             reduce using rule 88 (element -> boolean .)
    THEN            reduce using rule 88 (element -> boolean .)
    AND             reduce using rule 88 (element -> boolean .)
    OR              reduce using rule 88 (element -> boolean .)
    DO              reduce using rule 88 (element -> boolean .)
    SEMICOLON       reduce using rule 88 (element -> boolean .)
    END             reduce using rule 88 (element -> boolean .)
    UNTIL           reduce using rule 88 (element -> boolean .)
    TO              reduce using rule 88 (element -> boolean .)
    DOWNTO          reduce using rule 88 (element -> boolean .)
    ELSE            reduce using rule 88 (element -> boolean .)
    RPAREN          reduce using rule 88 (element -> boolean .)
    COMMA           reduce using rule 88 (element -> boolean .)
    RBRACKET        reduce using rule 88 (element -> boolean .)


state 91

    (89) element -> LPAREN . expression RPAREN
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 137
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 92

    (90) element -> NOT . element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    element                        shift and go to state 138
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 93

    (91) element -> function_call_inline .

    TIMES           reduce using rule 91 (element -> function_call_inline .)
    DIVISION        reduce using rule 91 (element -> function_call_inline .)
    PLUS            reduce using rule 91 (element -> function_call_inline .)
    MINUS           reduce using rule 91 (element -> function_call_inline .)
    DIV             reduce using rule 91 (element -> function_call_inline .)
    MOD             reduce using rule 91 (element -> function_call_inline .)
    EQ              reduce using rule 91 (element -> function_call_inline .)
    NEQ             reduce using rule 91 (element -> function_call_inline .)
    LT              reduce using rule 91 (element -> function_call_inline .)
    LTE             reduce using rule 91 (element -> function_call_inline .)
    GT              reduce using rule 91 (element -> function_call_inline .)
    GTE             reduce using rule 91 (element -> function_call_inline .)
    THEN            reduce using rule 91 (element -> function_call_inline .)
    AND             reduce using rule 91 (element -> function_call_inline .)
    OR              reduce using rule 91 (element -> function_call_inline .)
    DO              reduce using rule 91 (element -> function_call_inline .)
    SEMICOLON       reduce using rule 91 (element -> function_call_inline .)
    END             reduce using rule 91 (element -> function_call_inline .)
    UNTIL           reduce using rule 91 (element -> function_call_inline .)
    TO              reduce using rule 91 (element -> function_call_inline .)
    DOWNTO          reduce using rule 91 (element -> function_call_inline .)
    ELSE            reduce using rule 91 (element -> function_call_inline .)
    RPAREN          reduce using rule 91 (element -> function_call_inline .)
    COMMA           reduce using rule 91 (element -> function_call_inline .)
    RBRACKET        reduce using rule 91 (element -> function_call_inline .)


state 94

    (94) real -> REAL .

    TIMES           reduce using rule 94 (real -> REAL .)
    DIVISION        reduce using rule 94 (real -> REAL .)
    PLUS            reduce using rule 94 (real -> REAL .)
    MINUS           reduce using rule 94 (real -> REAL .)
    DIV             reduce using rule 94 (real -> REAL .)
    MOD             reduce using rule 94 (real -> REAL .)
    EQ              reduce using rule 94 (real -> REAL .)
    NEQ             reduce using rule 94 (real -> REAL .)
    LT              reduce using rule 94 (real -> REAL .)
    LTE             reduce using rule 94 (real -> REAL .)
    GT              reduce using rule 94 (real -> REAL .)
    GTE             reduce using rule 94 (real -> REAL .)
    THEN            reduce using rule 94 (real -> REAL .)
    AND             reduce using rule 94 (real -> REAL .)
    OR              reduce using rule 94 (real -> REAL .)
    DO              reduce using rule 94 (real -> REAL .)
    SEMICOLON       reduce using rule 94 (real -> REAL .)
    END             reduce using rule 94 (real -> REAL .)
    UNTIL           reduce using rule 94 (real -> REAL .)
    TO              reduce using rule 94 (real -> REAL .)
    DOWNTO          reduce using rule 94 (real -> REAL .)
    ELSE            reduce using rule 94 (real -> REAL .)
    RPAREN          reduce using rule 94 (real -> REAL .)
    COMMA           reduce using rule 94 (real -> REAL .)
    RBRACKET        reduce using rule 94 (real -> REAL .)


state 95

    (96) string -> STRING .

    TIMES           reduce using rule 96 (string -> STRING .)
    DIVISION        reduce using rule 96 (string -> STRING .)
    PLUS            reduce using rule 96 (string -> STRING .)
    MINUS           reduce using rule 96 (string -> STRING .)
    DIV             reduce using rule 96 (string -> STRING .)
    MOD             reduce using rule 96 (string -> STRING .)
    EQ              reduce using rule 96 (string -> STRING .)
    NEQ             reduce using rule 96 (string -> STRING .)
    LT              reduce using rule 96 (string -> STRING .)
    LTE             reduce using rule 96 (string -> STRING .)
    GT              reduce using rule 96 (string -> STRING .)
    GTE             reduce using rule 96 (string -> STRING .)
    THEN            reduce using rule 96 (string -> STRING .)
    AND             reduce using rule 96 (string -> STRING .)
    OR              reduce using rule 96 (string -> STRING .)
    DO              reduce using rule 96 (string -> STRING .)
    SEMICOLON       reduce using rule 96 (string -> STRING .)
    END             reduce using rule 96 (string -> STRING .)
    UNTIL           reduce using rule 96 (string -> STRING .)
    TO              reduce using rule 96 (string -> STRING .)
    DOWNTO          reduce using rule 96 (string -> STRING .)
    ELSE            reduce using rule 96 (string -> STRING .)
    RPAREN          reduce using rule 96 (string -> STRING .)
    COMMA           reduce using rule 96 (string -> STRING .)
    RBRACKET        reduce using rule 96 (string -> STRING .)


state 96

    (97) char -> CHAR .

    TIMES           reduce using rule 97 (char -> CHAR .)
    DIVISION        reduce using rule 97 (char -> CHAR .)
    PLUS            reduce using rule 97 (char -> CHAR .)
    MINUS           reduce using rule 97 (char -> CHAR .)
    DIV             reduce using rule 97 (char -> CHAR .)
    MOD             reduce using rule 97 (char -> CHAR .)
    EQ              reduce using rule 97 (char -> CHAR .)
    NEQ             reduce using rule 97 (char -> CHAR .)
    LT              reduce using rule 97 (char -> CHAR .)
    LTE             reduce using rule 97 (char -> CHAR .)
    GT              reduce using rule 97 (char -> CHAR .)
    GTE             reduce using rule 97 (char -> CHAR .)
    THEN            reduce using rule 97 (char -> CHAR .)
    AND             reduce using rule 97 (char -> CHAR .)
    OR              reduce using rule 97 (char -> CHAR .)
    DO              reduce using rule 97 (char -> CHAR .)
    SEMICOLON       reduce using rule 97 (char -> CHAR .)
    END             reduce using rule 97 (char -> CHAR .)
    UNTIL           reduce using rule 97 (char -> CHAR .)
    TO              reduce using rule 97 (char -> CHAR .)
    DOWNTO          reduce using rule 97 (char -> CHAR .)
    ELSE            reduce using rule 97 (char -> CHAR .)
    RPAREN          reduce using rule 97 (char -> CHAR .)
    COMMA           reduce using rule 97 (char -> CHAR .)
    RBRACKET        reduce using rule 97 (char -> CHAR .)


state 97

    (98) boolean -> TRUE .

    TIMES           reduce using rule 98 (boolean -> TRUE .)
    DIVISION        reduce using rule 98 (boolean -> TRUE .)
    PLUS            reduce using rule 98 (boolean -> TRUE .)
    MINUS           reduce using rule 98 (boolean -> TRUE .)
    DIV             reduce using rule 98 (boolean -> TRUE .)
    MOD             reduce using rule 98 (boolean -> TRUE .)
    EQ              reduce using rule 98 (boolean -> TRUE .)
    NEQ             reduce using rule 98 (boolean -> TRUE .)
    LT              reduce using rule 98 (boolean -> TRUE .)
    LTE             reduce using rule 98 (boolean -> TRUE .)
    GT              reduce using rule 98 (boolean -> TRUE .)
    GTE             reduce using rule 98 (boolean -> TRUE .)
    THEN            reduce using rule 98 (boolean -> TRUE .)
    AND             reduce using rule 98 (boolean -> TRUE .)
    OR              reduce using rule 98 (boolean -> TRUE .)
    DO              reduce using rule 98 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 98 (boolean -> TRUE .)
    END             reduce using rule 98 (boolean -> TRUE .)
    UNTIL           reduce using rule 98 (boolean -> TRUE .)
    TO              reduce using rule 98 (boolean -> TRUE .)
    DOWNTO          reduce using rule 98 (boolean -> TRUE .)
    ELSE            reduce using rule 98 (boolean -> TRUE .)
    RPAREN          reduce using rule 98 (boolean -> TRUE .)
    COMMA           reduce using rule 98 (boolean -> TRUE .)
    RBRACKET        reduce using rule 98 (boolean -> TRUE .)


state 98

    (99) boolean -> FALSE .

    TIMES           reduce using rule 99 (boolean -> FALSE .)
    DIVISION        reduce using rule 99 (boolean -> FALSE .)
    PLUS            reduce using rule 99 (boolean -> FALSE .)
    MINUS           reduce using rule 99 (boolean -> FALSE .)
    DIV             reduce using rule 99 (boolean -> FALSE .)
    MOD             reduce using rule 99 (boolean -> FALSE .)
    EQ              reduce using rule 99 (boolean -> FALSE .)
    NEQ             reduce using rule 99 (boolean -> FALSE .)
    LT              reduce using rule 99 (boolean -> FALSE .)
    LTE             reduce using rule 99 (boolean -> FALSE .)
    GT              reduce using rule 99 (boolean -> FALSE .)
    GTE             reduce using rule 99 (boolean -> FALSE .)
    THEN            reduce using rule 99 (boolean -> FALSE .)
    AND             reduce using rule 99 (boolean -> FALSE .)
    OR              reduce using rule 99 (boolean -> FALSE .)
    DO              reduce using rule 99 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 99 (boolean -> FALSE .)
    END             reduce using rule 99 (boolean -> FALSE .)
    UNTIL           reduce using rule 99 (boolean -> FALSE .)
    TO              reduce using rule 99 (boolean -> FALSE .)
    DOWNTO          reduce using rule 99 (boolean -> FALSE .)
    ELSE            reduce using rule 99 (boolean -> FALSE .)
    RPAREN          reduce using rule 99 (boolean -> FALSE .)
    COMMA           reduce using rule 99 (boolean -> FALSE .)
    RBRACKET        reduce using rule 99 (boolean -> FALSE .)


state 99

    (57) while_statement -> WHILE expression . DO statement
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    DO              shift and go to state 139
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 100

    (58) repeat_statement -> REPEAT statement . UNTIL expression

    UNTIL           shift and go to state 140


state 101

    (59) for_statement -> FOR assignment_statement . TO expression DO statement
    (60) for_statement -> FOR assignment_statement . DOWNTO expression DO statement

    TO              shift and go to state 141
    DOWNTO          shift and go to state 142


state 102

    (61) assignment_statement -> identifier . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 79


state 103

    (11) variable_declaration -> identifier_list COLON type . SEMICOLON

    SEMICOLON       shift and go to state 143


state 104

    (12) identifier_list -> identifier COMMA identifier_list .

    COLON           reduce using rule 12 (identifier_list -> identifier COMMA identifier_list .)


state 105

    (31) parameter -> identifier COLON . type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 144

state 106

    (20) procedure_heading -> PROCEDURE identifier LPAREN parameter_list RPAREN .

    SEMICOLON       reduce using rule 20 (procedure_heading -> PROCEDURE identifier LPAREN parameter_list RPAREN .)


state 107

    (29) parameter_list -> parameter COMMA . parameter_list
    (29) parameter_list -> . parameter COMMA parameter_list
    (30) parameter_list -> . parameter
    (31) parameter -> . identifier COLON type
    (14) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 6

    parameter                      shift and go to state 70
    parameter_list                 shift and go to state 145
    identifier                     shift and go to state 67

state 108

    (23) function_heading -> FUNCTION identifier LPAREN RPAREN COLON . type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 146

state 109

    (25) function_heading -> FUNCTION identifier LPAREN parameter_list RPAREN . COLON type

    COLON           shift and go to state 147


state 110

    (37) type -> TSTRING LBRACKET integer RBRACKET .

    SEMICOLON       reduce using rule 37 (type -> TSTRING LBRACKET integer RBRACKET .)
    COMMA           reduce using rule 37 (type -> TSTRING LBRACKET integer RBRACKET .)
    RPAREN          reduce using rule 37 (type -> TSTRING LBRACKET integer RBRACKET .)


state 111

    (38) type -> TARRAY LBRACKET integer DOTDOT . integer RBRACKET OF type
    (95) integer -> . INTEGER

    INTEGER         shift and go to state 75

    integer                        shift and go to state 148

state 112

    (40) statement_sequence -> statement SEMICOLON statement_sequence .

    END             reduce using rule 40 (statement_sequence -> statement SEMICOLON statement_sequence .)


state 113

    (61) assignment_statement -> identifier ASSIGNMENT expression .
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    SEMICOLON       reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    END             reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    UNTIL           reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    TO              reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    DOWNTO          reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    ELSE            reduce using rule 61 (assignment_statement -> identifier ASSIGNMENT expression .)
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 114

    (51) procedure_or_function_call -> identifier LPAREN param_list . RPAREN
    (52) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 149
    COMMA           shift and go to state 150


state 115

    (53) param_list -> param .

    RPAREN          reduce using rule 53 (param_list -> param .)
    COMMA           reduce using rule 53 (param_list -> param .)


state 116

    (54) param -> expression .
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    RPAREN          reduce using rule 54 (param -> expression .)
    COMMA           reduce using rule 54 (param -> expression .)
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 117

    (55) if_statement -> IF expression THEN . statement ELSE statement
    (56) if_statement -> IF expression THEN . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    ELSE            reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement                      shift and go to state 151
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 118

    (62) expression -> expression and_or . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression_m                   shift and go to state 152
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 119

    (68) and_or -> AND .

    LPAREN          reduce using rule 68 (and_or -> AND .)
    NOT             reduce using rule 68 (and_or -> AND .)
    IDENTIFIER      reduce using rule 68 (and_or -> AND .)
    REAL            reduce using rule 68 (and_or -> AND .)
    INTEGER         reduce using rule 68 (and_or -> AND .)
    STRING          reduce using rule 68 (and_or -> AND .)
    CHAR            reduce using rule 68 (and_or -> AND .)
    TRUE            reduce using rule 68 (and_or -> AND .)
    FALSE           reduce using rule 68 (and_or -> AND .)


state 120

    (69) and_or -> OR .

    LPAREN          reduce using rule 69 (and_or -> OR .)
    NOT             reduce using rule 69 (and_or -> OR .)
    IDENTIFIER      reduce using rule 69 (and_or -> OR .)
    REAL            reduce using rule 69 (and_or -> OR .)
    INTEGER         reduce using rule 69 (and_or -> OR .)
    STRING          reduce using rule 69 (and_or -> OR .)
    CHAR            reduce using rule 69 (and_or -> OR .)
    TRUE            reduce using rule 69 (and_or -> OR .)
    FALSE           reduce using rule 69 (and_or -> OR .)


state 121

    (65) expression_m -> expression_m sign . expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression_s                   shift and go to state 153
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 122

    (72) sign -> PLUS .

    LPAREN          reduce using rule 72 (sign -> PLUS .)
    NOT             reduce using rule 72 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 72 (sign -> PLUS .)
    REAL            reduce using rule 72 (sign -> PLUS .)
    INTEGER         reduce using rule 72 (sign -> PLUS .)
    STRING          reduce using rule 72 (sign -> PLUS .)
    CHAR            reduce using rule 72 (sign -> PLUS .)
    TRUE            reduce using rule 72 (sign -> PLUS .)
    FALSE           reduce using rule 72 (sign -> PLUS .)


state 123

    (73) sign -> MINUS .

    LPAREN          reduce using rule 73 (sign -> MINUS .)
    NOT             reduce using rule 73 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 73 (sign -> MINUS .)
    REAL            reduce using rule 73 (sign -> MINUS .)
    INTEGER         reduce using rule 73 (sign -> MINUS .)
    STRING          reduce using rule 73 (sign -> MINUS .)
    CHAR            reduce using rule 73 (sign -> MINUS .)
    TRUE            reduce using rule 73 (sign -> MINUS .)
    FALSE           reduce using rule 73 (sign -> MINUS .)


state 124

    (74) sign -> DIV .

    LPAREN          reduce using rule 74 (sign -> DIV .)
    NOT             reduce using rule 74 (sign -> DIV .)
    IDENTIFIER      reduce using rule 74 (sign -> DIV .)
    REAL            reduce using rule 74 (sign -> DIV .)
    INTEGER         reduce using rule 74 (sign -> DIV .)
    STRING          reduce using rule 74 (sign -> DIV .)
    CHAR            reduce using rule 74 (sign -> DIV .)
    TRUE            reduce using rule 74 (sign -> DIV .)
    FALSE           reduce using rule 74 (sign -> DIV .)


state 125

    (75) sign -> MOD .

    LPAREN          reduce using rule 75 (sign -> MOD .)
    NOT             reduce using rule 75 (sign -> MOD .)
    IDENTIFIER      reduce using rule 75 (sign -> MOD .)
    REAL            reduce using rule 75 (sign -> MOD .)
    INTEGER         reduce using rule 75 (sign -> MOD .)
    STRING          reduce using rule 75 (sign -> MOD .)
    CHAR            reduce using rule 75 (sign -> MOD .)
    TRUE            reduce using rule 75 (sign -> MOD .)
    FALSE           reduce using rule 75 (sign -> MOD .)


state 126

    (76) sign -> EQ .

    LPAREN          reduce using rule 76 (sign -> EQ .)
    NOT             reduce using rule 76 (sign -> EQ .)
    IDENTIFIER      reduce using rule 76 (sign -> EQ .)
    REAL            reduce using rule 76 (sign -> EQ .)
    INTEGER         reduce using rule 76 (sign -> EQ .)
    STRING          reduce using rule 76 (sign -> EQ .)
    CHAR            reduce using rule 76 (sign -> EQ .)
    TRUE            reduce using rule 76 (sign -> EQ .)
    FALSE           reduce using rule 76 (sign -> EQ .)


state 127

    (77) sign -> NEQ .

    LPAREN          reduce using rule 77 (sign -> NEQ .)
    NOT             reduce using rule 77 (sign -> NEQ .)
    IDENTIFIER      reduce using rule 77 (sign -> NEQ .)
    REAL            reduce using rule 77 (sign -> NEQ .)
    INTEGER         reduce using rule 77 (sign -> NEQ .)
    STRING          reduce using rule 77 (sign -> NEQ .)
    CHAR            reduce using rule 77 (sign -> NEQ .)
    TRUE            reduce using rule 77 (sign -> NEQ .)
    FALSE           reduce using rule 77 (sign -> NEQ .)


state 128

    (78) sign -> LT .

    LPAREN          reduce using rule 78 (sign -> LT .)
    NOT             reduce using rule 78 (sign -> LT .)
    IDENTIFIER      reduce using rule 78 (sign -> LT .)
    REAL            reduce using rule 78 (sign -> LT .)
    INTEGER         reduce using rule 78 (sign -> LT .)
    STRING          reduce using rule 78 (sign -> LT .)
    CHAR            reduce using rule 78 (sign -> LT .)
    TRUE            reduce using rule 78 (sign -> LT .)
    FALSE           reduce using rule 78 (sign -> LT .)


state 129

    (79) sign -> LTE .

    LPAREN          reduce using rule 79 (sign -> LTE .)
    NOT             reduce using rule 79 (sign -> LTE .)
    IDENTIFIER      reduce using rule 79 (sign -> LTE .)
    REAL            reduce using rule 79 (sign -> LTE .)
    INTEGER         reduce using rule 79 (sign -> LTE .)
    STRING          reduce using rule 79 (sign -> LTE .)
    CHAR            reduce using rule 79 (sign -> LTE .)
    TRUE            reduce using rule 79 (sign -> LTE .)
    FALSE           reduce using rule 79 (sign -> LTE .)


state 130

    (80) sign -> GT .

    LPAREN          reduce using rule 80 (sign -> GT .)
    NOT             reduce using rule 80 (sign -> GT .)
    IDENTIFIER      reduce using rule 80 (sign -> GT .)
    REAL            reduce using rule 80 (sign -> GT .)
    INTEGER         reduce using rule 80 (sign -> GT .)
    STRING          reduce using rule 80 (sign -> GT .)
    CHAR            reduce using rule 80 (sign -> GT .)
    TRUE            reduce using rule 80 (sign -> GT .)
    FALSE           reduce using rule 80 (sign -> GT .)


state 131

    (81) sign -> GTE .

    LPAREN          reduce using rule 81 (sign -> GTE .)
    NOT             reduce using rule 81 (sign -> GTE .)
    IDENTIFIER      reduce using rule 81 (sign -> GTE .)
    REAL            reduce using rule 81 (sign -> GTE .)
    INTEGER         reduce using rule 81 (sign -> GTE .)
    STRING          reduce using rule 81 (sign -> GTE .)
    CHAR            reduce using rule 81 (sign -> GTE .)
    TRUE            reduce using rule 81 (sign -> GTE .)
    FALSE           reduce using rule 81 (sign -> GTE .)


state 132

    (67) expression_s -> expression_s psign . element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    element                        shift and go to state 154
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 133

    (70) psign -> TIMES .

    LPAREN          reduce using rule 70 (psign -> TIMES .)
    NOT             reduce using rule 70 (psign -> TIMES .)
    IDENTIFIER      reduce using rule 70 (psign -> TIMES .)
    REAL            reduce using rule 70 (psign -> TIMES .)
    INTEGER         reduce using rule 70 (psign -> TIMES .)
    STRING          reduce using rule 70 (psign -> TIMES .)
    CHAR            reduce using rule 70 (psign -> TIMES .)
    TRUE            reduce using rule 70 (psign -> TIMES .)
    FALSE           reduce using rule 70 (psign -> TIMES .)


state 134

    (71) psign -> DIVISION .

    LPAREN          reduce using rule 71 (psign -> DIVISION .)
    NOT             reduce using rule 71 (psign -> DIVISION .)
    IDENTIFIER      reduce using rule 71 (psign -> DIVISION .)
    REAL            reduce using rule 71 (psign -> DIVISION .)
    INTEGER         reduce using rule 71 (psign -> DIVISION .)
    STRING          reduce using rule 71 (psign -> DIVISION .)
    CHAR            reduce using rule 71 (psign -> DIVISION .)
    TRUE            reduce using rule 71 (psign -> DIVISION .)
    FALSE           reduce using rule 71 (psign -> DIVISION .)


state 135

    (83) element -> identifier LBRACKET . expression RBRACKET
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    identifier                     shift and go to state 85
    expression                     shift and go to state 155
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 136

    (92) function_call_inline -> identifier LPAREN . param_list RPAREN
    (93) function_call_inline -> identifier LPAREN . RPAREN
    (52) param_list -> . param_list COMMA param
    (53) param_list -> . param
    (54) param -> . expression
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    RPAREN          shift and go to state 157
    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    identifier                     shift and go to state 85
    param_list                     shift and go to state 156
    param                          shift and go to state 115
    expression                     shift and go to state 116
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 137

    (89) element -> LPAREN expression . RPAREN
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    RPAREN          shift and go to state 158
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 138

    (90) element -> NOT element .

    TIMES           reduce using rule 90 (element -> NOT element .)
    DIVISION        reduce using rule 90 (element -> NOT element .)
    PLUS            reduce using rule 90 (element -> NOT element .)
    MINUS           reduce using rule 90 (element -> NOT element .)
    DIV             reduce using rule 90 (element -> NOT element .)
    MOD             reduce using rule 90 (element -> NOT element .)
    EQ              reduce using rule 90 (element -> NOT element .)
    NEQ             reduce using rule 90 (element -> NOT element .)
    LT              reduce using rule 90 (element -> NOT element .)
    LTE             reduce using rule 90 (element -> NOT element .)
    GT              reduce using rule 90 (element -> NOT element .)
    GTE             reduce using rule 90 (element -> NOT element .)
    THEN            reduce using rule 90 (element -> NOT element .)
    AND             reduce using rule 90 (element -> NOT element .)
    OR              reduce using rule 90 (element -> NOT element .)
    DO              reduce using rule 90 (element -> NOT element .)
    SEMICOLON       reduce using rule 90 (element -> NOT element .)
    END             reduce using rule 90 (element -> NOT element .)
    UNTIL           reduce using rule 90 (element -> NOT element .)
    TO              reduce using rule 90 (element -> NOT element .)
    DOWNTO          reduce using rule 90 (element -> NOT element .)
    ELSE            reduce using rule 90 (element -> NOT element .)
    RPAREN          reduce using rule 90 (element -> NOT element .)
    COMMA           reduce using rule 90 (element -> NOT element .)
    RBRACKET        reduce using rule 90 (element -> NOT element .)


state 139

    (57) while_statement -> WHILE expression DO . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    ELSE            reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement                      shift and go to state 159
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 140

    (58) repeat_statement -> REPEAT statement UNTIL . expression
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 160
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 141

    (59) for_statement -> FOR assignment_statement TO . expression DO statement
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 161
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 142

    (60) for_statement -> FOR assignment_statement DOWNTO . expression DO statement
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expression                     shift and go to state 162
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 143

    (11) variable_declaration -> identifier_list COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 11 (variable_declaration -> identifier_list COLON type SEMICOLON .)
    BEGIN           reduce using rule 11 (variable_declaration -> identifier_list COLON type SEMICOLON .)


state 144

    (31) parameter -> identifier COLON type .

    COMMA           reduce using rule 31 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 31 (parameter -> identifier COLON type .)


state 145

    (29) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 29 (parameter_list -> parameter COMMA parameter_list .)


state 146

    (23) function_heading -> FUNCTION identifier LPAREN RPAREN COLON type .

    SEMICOLON       reduce using rule 23 (function_heading -> FUNCTION identifier LPAREN RPAREN COLON type .)


state 147

    (25) function_heading -> FUNCTION identifier LPAREN parameter_list RPAREN COLON . type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 163

state 148

    (38) type -> TARRAY LBRACKET integer DOTDOT integer . RBRACKET OF type

    RBRACKET        shift and go to state 164


state 149

    (51) procedure_or_function_call -> identifier LPAREN param_list RPAREN .

    SEMICOLON       reduce using rule 51 (procedure_or_function_call -> identifier LPAREN param_list RPAREN .)
    END             reduce using rule 51 (procedure_or_function_call -> identifier LPAREN param_list RPAREN .)
    UNTIL           reduce using rule 51 (procedure_or_function_call -> identifier LPAREN param_list RPAREN .)
    ELSE            reduce using rule 51 (procedure_or_function_call -> identifier LPAREN param_list RPAREN .)


state 150

    (52) param_list -> param_list COMMA . param
    (54) param -> . expression
    (62) expression -> . expression and_or expression_m
    (63) expression -> . expression_m
    (64) expression_m -> . expression_s
    (65) expression_m -> . expression_m sign expression_s
    (66) expression_s -> . element
    (67) expression_s -> . expression_s psign element
    (82) element -> . identifier
    (83) element -> . identifier LBRACKET expression RBRACKET
    (84) element -> . real
    (85) element -> . integer
    (86) element -> . string
    (87) element -> . char
    (88) element -> . boolean
    (89) element -> . LPAREN expression RPAREN
    (90) element -> . NOT element
    (91) element -> . function_call_inline
    (14) identifier -> . IDENTIFIER
    (94) real -> . REAL
    (95) integer -> . INTEGER
    (96) string -> . STRING
    (97) char -> . CHAR
    (98) boolean -> . TRUE
    (99) boolean -> . FALSE
    (92) function_call_inline -> . identifier LPAREN param_list RPAREN
    (93) function_call_inline -> . identifier LPAREN RPAREN

    LPAREN          shift and go to state 91
    NOT             shift and go to state 92
    IDENTIFIER      shift and go to state 6
    REAL            shift and go to state 94
    INTEGER         shift and go to state 75
    STRING          shift and go to state 95
    CHAR            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    param                          shift and go to state 165
    expression                     shift and go to state 116
    expression_m                   shift and go to state 82
    expression_s                   shift and go to state 83
    element                        shift and go to state 84
    identifier                     shift and go to state 85
    real                           shift and go to state 86
    integer                        shift and go to state 87
    string                         shift and go to state 88
    char                           shift and go to state 89
    boolean                        shift and go to state 90
    function_call_inline           shift and go to state 93

state 151

    (55) if_statement -> IF expression THEN statement . ELSE statement
    (56) if_statement -> IF expression THEN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 166
    SEMICOLON       reduce using rule 56 (if_statement -> IF expression THEN statement .)
    END             reduce using rule 56 (if_statement -> IF expression THEN statement .)
    UNTIL           reduce using rule 56 (if_statement -> IF expression THEN statement .)

  ! ELSE            [ reduce using rule 56 (if_statement -> IF expression THEN statement .) ]


state 152

    (62) expression -> expression and_or expression_m .
    (65) expression_m -> expression_m . sign expression_s
    (72) sign -> . PLUS
    (73) sign -> . MINUS
    (74) sign -> . DIV
    (75) sign -> . MOD
    (76) sign -> . EQ
    (77) sign -> . NEQ
    (78) sign -> . LT
    (79) sign -> . LTE
    (80) sign -> . GT
    (81) sign -> . GTE

    THEN            reduce using rule 62 (expression -> expression and_or expression_m .)
    AND             reduce using rule 62 (expression -> expression and_or expression_m .)
    OR              reduce using rule 62 (expression -> expression and_or expression_m .)
    DO              reduce using rule 62 (expression -> expression and_or expression_m .)
    SEMICOLON       reduce using rule 62 (expression -> expression and_or expression_m .)
    END             reduce using rule 62 (expression -> expression and_or expression_m .)
    UNTIL           reduce using rule 62 (expression -> expression and_or expression_m .)
    TO              reduce using rule 62 (expression -> expression and_or expression_m .)
    DOWNTO          reduce using rule 62 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 62 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 62 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 62 (expression -> expression and_or expression_m .)
    RBRACKET        reduce using rule 62 (expression -> expression and_or expression_m .)
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    DIV             shift and go to state 124
    MOD             shift and go to state 125
    EQ              shift and go to state 126
    NEQ             shift and go to state 127
    LT              shift and go to state 128
    LTE             shift and go to state 129
    GT              shift and go to state 130
    GTE             shift and go to state 131

    sign                           shift and go to state 121

state 153

    (65) expression_m -> expression_m sign expression_s .
    (67) expression_s -> expression_s . psign element
    (70) psign -> . TIMES
    (71) psign -> . DIVISION

    PLUS            reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    MINUS           reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    DIV             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    MOD             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    EQ              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    NEQ             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    LT              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    LTE             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    GT              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    GTE             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    THEN            reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    AND             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    OR              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    DO              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    SEMICOLON       reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    END             reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    UNTIL           reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    TO              reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    DOWNTO          reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    ELSE            reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    RPAREN          reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    COMMA           reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    RBRACKET        reduce using rule 65 (expression_m -> expression_m sign expression_s .)
    TIMES           shift and go to state 133
    DIVISION        shift and go to state 134

    psign                          shift and go to state 132

state 154

    (67) expression_s -> expression_s psign element .

    TIMES           reduce using rule 67 (expression_s -> expression_s psign element .)
    DIVISION        reduce using rule 67 (expression_s -> expression_s psign element .)
    PLUS            reduce using rule 67 (expression_s -> expression_s psign element .)
    MINUS           reduce using rule 67 (expression_s -> expression_s psign element .)
    DIV             reduce using rule 67 (expression_s -> expression_s psign element .)
    MOD             reduce using rule 67 (expression_s -> expression_s psign element .)
    EQ              reduce using rule 67 (expression_s -> expression_s psign element .)
    NEQ             reduce using rule 67 (expression_s -> expression_s psign element .)
    LT              reduce using rule 67 (expression_s -> expression_s psign element .)
    LTE             reduce using rule 67 (expression_s -> expression_s psign element .)
    GT              reduce using rule 67 (expression_s -> expression_s psign element .)
    GTE             reduce using rule 67 (expression_s -> expression_s psign element .)
    THEN            reduce using rule 67 (expression_s -> expression_s psign element .)
    AND             reduce using rule 67 (expression_s -> expression_s psign element .)
    OR              reduce using rule 67 (expression_s -> expression_s psign element .)
    DO              reduce using rule 67 (expression_s -> expression_s psign element .)
    SEMICOLON       reduce using rule 67 (expression_s -> expression_s psign element .)
    END             reduce using rule 67 (expression_s -> expression_s psign element .)
    UNTIL           reduce using rule 67 (expression_s -> expression_s psign element .)
    TO              reduce using rule 67 (expression_s -> expression_s psign element .)
    DOWNTO          reduce using rule 67 (expression_s -> expression_s psign element .)
    ELSE            reduce using rule 67 (expression_s -> expression_s psign element .)
    RPAREN          reduce using rule 67 (expression_s -> expression_s psign element .)
    COMMA           reduce using rule 67 (expression_s -> expression_s psign element .)
    RBRACKET        reduce using rule 67 (expression_s -> expression_s psign element .)


state 155

    (83) element -> identifier LBRACKET expression . RBRACKET
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    RBRACKET        shift and go to state 167
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 156

    (92) function_call_inline -> identifier LPAREN param_list . RPAREN
    (52) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 168
    COMMA           shift and go to state 150


state 157

    (93) function_call_inline -> identifier LPAREN RPAREN .

    TIMES           reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    DIVISION        reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    PLUS            reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    MINUS           reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    DIV             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    MOD             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    EQ              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    NEQ             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    LT              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    LTE             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    GT              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    GTE             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    THEN            reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    AND             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    OR              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    DO              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    SEMICOLON       reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    END             reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    UNTIL           reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    TO              reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    DOWNTO          reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    ELSE            reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    COMMA           reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)
    RBRACKET        reduce using rule 93 (function_call_inline -> identifier LPAREN RPAREN .)


state 158

    (89) element -> LPAREN expression RPAREN .

    TIMES           reduce using rule 89 (element -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 89 (element -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 89 (element -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 89 (element -> LPAREN expression RPAREN .)
    DIV             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    MOD             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    EQ              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    LT              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    LTE             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    GT              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    GTE             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    THEN            reduce using rule 89 (element -> LPAREN expression RPAREN .)
    AND             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    OR              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    DO              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 89 (element -> LPAREN expression RPAREN .)
    END             reduce using rule 89 (element -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 89 (element -> LPAREN expression RPAREN .)
    TO              reduce using rule 89 (element -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 89 (element -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 89 (element -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 89 (element -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 89 (element -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 89 (element -> LPAREN expression RPAREN .)


state 159

    (57) while_statement -> WHILE expression DO statement .

    SEMICOLON       reduce using rule 57 (while_statement -> WHILE expression DO statement .)
    END             reduce using rule 57 (while_statement -> WHILE expression DO statement .)
    UNTIL           reduce using rule 57 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 57 (while_statement -> WHILE expression DO statement .)


state 160

    (58) repeat_statement -> REPEAT statement UNTIL expression .
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    SEMICOLON       reduce using rule 58 (repeat_statement -> REPEAT statement UNTIL expression .)
    END             reduce using rule 58 (repeat_statement -> REPEAT statement UNTIL expression .)
    UNTIL           reduce using rule 58 (repeat_statement -> REPEAT statement UNTIL expression .)
    ELSE            reduce using rule 58 (repeat_statement -> REPEAT statement UNTIL expression .)
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 161

    (59) for_statement -> FOR assignment_statement TO expression . DO statement
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    DO              shift and go to state 169
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 162

    (60) for_statement -> FOR assignment_statement DOWNTO expression . DO statement
    (62) expression -> expression . and_or expression_m
    (68) and_or -> . AND
    (69) and_or -> . OR

    DO              shift and go to state 170
    AND             shift and go to state 119
    OR              shift and go to state 120

    and_or                         shift and go to state 118

state 163

    (25) function_heading -> FUNCTION identifier LPAREN parameter_list RPAREN COLON type .

    SEMICOLON       reduce using rule 25 (function_heading -> FUNCTION identifier LPAREN parameter_list RPAREN COLON type .)


state 164

    (38) type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET . OF type

    OF              shift and go to state 171


state 165

    (52) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 52 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 52 (param_list -> param_list COMMA param .)


state 166

    (55) if_statement -> IF expression THEN statement ELSE . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    ELSE            reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    statement                      shift and go to state 172
    assignment_statement           shift and go to state 51
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 167

    (83) element -> identifier LBRACKET expression RBRACKET .

    TIMES           reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    DIVISION        reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    DIV             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    MOD             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    EQ              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    LT              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    LTE             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    GT              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    GTE             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    THEN            reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    AND             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    OR              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    DO              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    END             reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    UNTIL           reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    TO              reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 83 (element -> identifier LBRACKET expression RBRACKET .)


state 168

    (92) function_call_inline -> identifier LPAREN param_list RPAREN .

    TIMES           reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DIVISION        reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    PLUS            reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MINUS           reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DIV             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MOD             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    EQ              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    NEQ             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LT              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LTE             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GT              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GTE             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    THEN            reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    AND             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    OR              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DO              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    SEMICOLON       reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    END             reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    UNTIL           reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    TO              reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DOWNTO          reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    ELSE            reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RPAREN          reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    COMMA           reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RBRACKET        reduce using rule 92 (function_call_inline -> identifier LPAREN param_list RPAREN .)


state 169

    (59) for_statement -> FOR assignment_statement TO expression DO . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    ELSE            reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    assignment_statement           shift and go to state 51
    statement                      shift and go to state 173
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 170

    (60) for_statement -> FOR assignment_statement DOWNTO expression DO . statement
    (42) statement -> . assignment_statement
    (43) statement -> . statement_part
    (44) statement -> . if_statement
    (45) statement -> . while_statement
    (46) statement -> . repeat_statement
    (47) statement -> . for_statement
    (48) statement -> . procedure_or_function_call
    (49) statement -> . empty
    (61) assignment_statement -> . identifier ASSIGNMENT expression
    (39) statement_part -> . BEGIN statement_sequence END
    (55) if_statement -> . IF expression THEN statement ELSE statement
    (56) if_statement -> . IF expression THEN statement
    (57) while_statement -> . WHILE expression DO statement
    (58) repeat_statement -> . REPEAT statement UNTIL expression
    (59) for_statement -> . FOR assignment_statement TO expression DO statement
    (60) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (50) procedure_or_function_call -> . identifier
    (51) procedure_or_function_call -> . identifier LPAREN param_list RPAREN
    (5) empty -> .
    (14) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 36
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    REPEAT          shift and go to state 62
    FOR             shift and go to state 63
    ELSE            reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    UNTIL           reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 6

    assignment_statement           shift and go to state 51
    statement                      shift and go to state 174
    statement_part                 shift and go to state 52
    if_statement                   shift and go to state 53
    while_statement                shift and go to state 54
    repeat_statement               shift and go to state 55
    for_statement                  shift and go to state 56
    procedure_or_function_call     shift and go to state 57
    empty                          shift and go to state 58
    identifier                     shift and go to state 59

state 171

    (38) type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF . type
    (32) type -> . TREAL
    (33) type -> . TINTEGER
    (34) type -> . TCHAR
    (35) type -> . TSTRING
    (36) type -> . TBOOLEAN
    (37) type -> . TSTRING LBRACKET integer RBRACKET
    (38) type -> . TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type

    TREAL           shift and go to state 28
    TINTEGER        shift and go to state 29
    TCHAR           shift and go to state 30
    TSTRING         shift and go to state 31
    TBOOLEAN        shift and go to state 32
    TARRAY          shift and go to state 33

    type                           shift and go to state 175

state 172

    (55) if_statement -> IF expression THEN statement ELSE statement .

    SEMICOLON       reduce using rule 55 (if_statement -> IF expression THEN statement ELSE statement .)
    END             reduce using rule 55 (if_statement -> IF expression THEN statement ELSE statement .)
    UNTIL           reduce using rule 55 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 55 (if_statement -> IF expression THEN statement ELSE statement .)


state 173

    (59) for_statement -> FOR assignment_statement TO expression DO statement .

    SEMICOLON       reduce using rule 59 (for_statement -> FOR assignment_statement TO expression DO statement .)
    END             reduce using rule 59 (for_statement -> FOR assignment_statement TO expression DO statement .)
    UNTIL           reduce using rule 59 (for_statement -> FOR assignment_statement TO expression DO statement .)
    ELSE            reduce using rule 59 (for_statement -> FOR assignment_statement TO expression DO statement .)


state 174

    (60) for_statement -> FOR assignment_statement DOWNTO expression DO statement .

    SEMICOLON       reduce using rule 60 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)
    END             reduce using rule 60 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)
    UNTIL           reduce using rule 60 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)
    ELSE            reduce using rule 60 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)


state 175

    (38) type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type .

    SEMICOLON       reduce using rule 38 (type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type .)
    COMMA           reduce using rule 38 (type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type .)
    RPAREN          reduce using rule 38 (type -> TARRAY LBRACKET integer DOTDOT integer RBRACKET OF type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
